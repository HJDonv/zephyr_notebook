使用CMAKE指令之后，会创建一系列的makefile，这里对这些makefile进行学习。
了解后续在build文件夹下执行make之后会发生的过程，希望能够总体去理解编译框架，
能理解多少就理解多少吧，一点点记录，这里编译了bluetooth的beacon例程。

2018/04/03 22：46
1、
# Remove some rules from gmake that .SUFFIXES does not remove.
SUFFIXES =

.SUFFIXES: .hpux_make_needs_suffix_list

这里的.hpux_make_needs_suffix_list是什么？在哪里？
这样.SUFFIXES相当于不支持任何后缀了？
2、
执行make，其实就是执行make all，其中make all是个多规则目标。所以我把all目标的全部依赖列了一遍。
all: CMakeFiles/app.dir/all
all: zephyr/CMakeFiles/zephyr.dir/all
all: zephyr/CMakeFiles/zephyr_prebuilt.dir/all
all: zephyr/CMakeFiles/offsets.dir/all
all: zephyr/CMakeFiles/kernel_elf.dir/all
all: zephyr/subsys/bluetooth/common/CMakeFiles/subsys__bluetooth__common.dir/all
all: zephyr/subsys/bluetooth/host/CMakeFiles/subsys__bluetooth__host.dir/all
all: zephyr/subsys/bluetooth/controller/CMakeFiles/subsys__bluetooth__controller.dir/all
all: zephyr/subsys/net/CMakeFiles/subsys__net.dir/all
all: zephyr/kernel/CMakeFiles/kernel.dir/all    

CMakeFiles/app.dir/all又有别的依赖，一层嵌套一层，但是最后会调用这两个语句
$(MAKE) -f zephyr/CMakeFiles/xxxx/build.make zephyr/CMakeFiles/xxxx/depend
$(MAKE) -f zephyr/CMakeFiles/xxxx/build.make zephyr/CMakeFiles/xxxx/build

make 在读入所有 makefile 文件之后，首先将所读取的每个 makefile 作为一个目标，试着去更新它。由于build.make中有明确的depend和build目标生成规则，而它们又是.PHONY，所以成功更新depend目标和build目标，其中depend目标的规则生成cmake使用的文件，不懂，暂时不看。
build目标规则会通过py，json等文件生成一系列后续要用的.c .h文件。

3、
# A target that is always out of date.
cmake_force:

.PHONY : cmake_force

这个目标放在作为哪个目标的依赖，只要make那个目标，一定会被重建，而不会出现up to date的情况。

2018.04.05 00:27
1、
在使用交叉编译工具链arm-zephyr-eabi-gcc把.c编译成.o文件时候，会用到ccache命令，百度：ccache是一个编译缓存，通过缓存以前的汇编和检测时再次执行相同的编译以加快重新编译。
2、
build/CMakeFiles里面有许多xxx.dir文件夹，里面有menuconfig生成规则，用户app的.o生成规则，反正都是一些系统外的第三方工具的东西。
build/zephyr/CMakiles里面有许多xxx.dir文件夹，里面有许多和zephyr系统相关的.o文件生成规则。
3、
cmake -E env [--unset=NAME]... [NAME=VALUE]... COMMAND [ARG]...
这条指令让COMMAND能够在指令指定的环境中运行，但是这种环境只在第一次使用生效，网页上描述的几个操作都会导致环境变量刷新。不是很懂。
https://stackoverflow.com/questions/690223/how-to-retrieve-a-user-environment-variable-in-cmake-windows

2018.04.05 13:19
1、
all: zephyr/CMakeFiles/zephyr.dir/all的规则应该会生成一堆的.c.obj文件，但是最后结果是没有的，可能在后续哪个步骤删掉了。
追加1：之前的认知是错误的，理解错误原因是makefile中的目标不等于文件，并没有删除的步骤，而是根本没有生成。
2、
使用script来记录终端信息，查看一下执行make的过程，找找看是在哪里删掉这些文件的。使用script进行log，会包含很多转义字符，看起来不方便，参考以下方法解决：
https://stackoverflow.com/questions/6306728/remove-ansi-codes-when-storing-script-output

2018.04.05 00:20
1、
make操作之后的log里面会有许多：
Scanning dependencies of target xxxx
Built target xxxx
但是这两行都没在makefile中找到，可能是cmake内部打印的。

2018.04.07 23:43
1、
这两天了解了CMAKE基本语法，并不是很难，makefile是根据zephyr团队写的CMAKE脚本自动生成的，所以打算先把makefile放一放，先学习CMAKE。（感觉makefile不用看，因为是根据CMAKE框架自动生成的）

2、
target链接库的时候，有两个命令：
LINK_LIBRARIES() :这个命令要注意必须放在ADD_EXECUTABLE前面。
TARGET_LINK_LIBRARIES()

3、
CMAKE学习路线参考了以下网址：https://www.kancloud.cn/itfanr/cmake-practice/82988

4、
对于*_SOURCE_DIR和*_BINARY_DIR这些变量的具体意义，参考以下链接：
johnnado.com/cmake-directory-variables
或者官方文档。可以使用MESSAGE指令打印出来感受一下。

2018.04.08 22:55
1、
CMAKE里面存在许多域（GLOBAL、DIRECTROY、TARGET...)，每个域有对应的对象。
因为对象属于对应的域，所以对象有对应域的各种标准属性（PROPERTY），通过CMAKE的set_property和get_property命令
可以对设置和获取这些属性值。其中GLOBAL域没有对象。
在boilerplate.cmake文件中一开始便在GLOBAL中定义了许多PROPERTY，通过这个域可以模拟全局变量的作用，所以后面一定在某个地方使用到这些全局变量。

2、
extensions.cmake中定义了一些函数，看上去以后修改app最顶层的CMakeLists会用到。
target_include_directories的具体用法参考：
https://stackoverflow.com/questions/31969547/what-is-the-difference-between-include-directories-and-target-include-directorie
https://stackoverflow.com/questions/26243169/cmake-target-include-directories-meaning-of-scope/26243547
https://stackoverflow.com/questions/26037954/cmake-target-link-libraries-interface-dependencies

2018.04.10 23:04
1、
对于lib和include在编译过程中的作用不是很清晰，上网多看看。
下面是预处理时候，搜索include文件的顺序：
https://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html#Directory-Options
2、
CMAKE_CXX_FLAGS和COMPILE_DEFINITIONS区别，对某个target进行编译时候，会在哪里找编译选项
https://stackoverflow.com/questions/39501481/difference-between-add-compile-options-and-setcmake-cxx-flags
3、
objcect libraries不能被直接“link”到target，但是可以通过Interface libraries间接link过去，不是很懂，先留着。